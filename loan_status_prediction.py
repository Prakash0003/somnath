# -*- coding: utf-8 -*-
"""Loan Status Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_rtF3Vesi-HL2Hsy7LKlo2-0MM6p-Es
"""

from PIL import Image
img = Image.open('/content/loan.jpg')
img

"""#Data Import and Overview:

#Imported necessary libraries and loaded the dataset.
#Displayed the first few rows and descriptive statistics to understand the data structure
"""

# Commented out IPython magic to ensure Python compatibility.
# import modules
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
# %matplotlib inline
data=pd.read_csv('/content/loan_data.csv')
data.head()

data.shape

data.describe

data.info()

data.isnull().sum()

#Data Cleaning:
              #Handled missing values by filling them with mode or mean values for respective columns:
              #Filled missing Gender, Dependents, and Self_Employed with mode.
              #Filled missing LoanAmount, Loan_Amount_Term, and Credit_History with mean.
              #Verified that there were no more missing values.

data['Gender']=data['Gender'].fillna(data['Gender'].mode()[0])
data['Dependents']=data['Dependents'].fillna(data['Dependents'].mode()[0])
data['Self_Employed']=data['Self_Employed'].fillna(data['Self_Employed'].mode()[0])
data['LoanAmount']=data['LoanAmount'].fillna(data['LoanAmount'].mean())
data['Loan_Amount_Term']=data['Loan_Amount_Term'].fillna(data['Loan_Amount_Term'].mean())
data['Credit_History']=data['Credit_History'].fillna(data['Credit_History'].mean())
data.isnull().sum()

sns.countplot(data['Gender'])

sns.countplot(data['Married'])

data['TotalIncome']=data['ApplicantIncome']+ data['CoapplicantIncome']
data.head()

sns.distplot(data['ApplicantIncome'])

data['ApplicantIncome']=np.log(data['ApplicantIncome'])
sns.distplot(data['ApplicantIncome'])

sns.distplot(data['CoapplicantIncome'])

data['CoapplicantIncome']=np.log(data['CoapplicantIncome'])
sns.distplot(data['CoapplicantIncome'])

sns.distplot(data['LoanAmount'])

data['LoanAmount']=np.log(data['LoanAmount'])
sns.distplot(data['LoanAmount'])

sns.distplot(data['Loan_Amount_Term'])

data['Loan_Amount_Term']=np.log(data['Loan_Amount_Term'])
sns.distplot(data['Loan_Amount_Term'])

sns.distplot(data['ApplicantIncome'])

data['ApplicantIncome']=np.log(data['ApplicantIncome'])
sns.distplot(data['ApplicantIncome'])

sns.distplot(data['TotalIncome'])

data['TotalIncome']=np.log(data['TotalIncome'])
sns.distplot(data['TotalIncome'])

cols = ['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount' ,'Loan_Amount_Term','TotalIncome','Loan_ID','CoapplicantIncome']
data.drop(columns = cols , axis = 1)

#Feature Engineering:

                    #Dropped less significant columns to reduce dimensionality and potential noise: ApplicantIncome, CoapplicantIncome, LoanAmount, Loan_Amount_Term, TotalIncome, Loan_ID, CoapplicantIncome.
                    #Encoded categorical variables using Label Encoding for columns: Loan_ID, Gender, Married, Education, Self_Employed, Property_Area, Loan_Status, Dependents.

from sklearn.preprocessing import LabelEncoder
cols=['Loan_ID','Gender','Married','Education','Self_Employed','Property_Area','Loan_Status','Dependents']
le=LabelEncoder()
for col in cols:
  data[col]=le.fit_transform(data[col])

data['CoapplicantIncome']=data['CoapplicantIncome'].fillna(data['CoapplicantIncome'].mean())

#Exploratory Data Analysis (EDA):

                                #Calculated the correlation matrix to understand the relationships between features.
                                #Visualized the correlation matrix using a heatmap

correlation=data.corr()
sns.heatmap(correlation,center=0,cmap="BuPu",annot=True)
plt.figure(figsize=(15,20))
plt.show()

x=data.drop(columns=['Loan_Status'],axis=1)
y=data['Loan_Status']

#Model Building:

              #Split the data into training and testing sets with an 80-20 split.
              #Built a Decision Tree Classifier with a maximum depth of 10.
              #Trained the model on the training se

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=25)
print(x_train.shape)
print(y_test.shape)

#Model Evaluation:

                 #Made predictions on the test set.
                 #Evaluated model performance using accuracy score and classification report.
                 #Achieved a certain level of accuracy and provided detailed classification metrics

from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score,classification_report
model=DecisionTreeClassifier(max_depth=10)
model.fit(x_train,y_train)
prediction=model.predict(x_test)
accuracy=accuracy_score(y_test,prediction)
print('accuracy_score',format(accuracy*100))
print('classification',classification_report(y_test,prediction))

plot=pd.DataFrame({'Actual':np.ravel(y_test),'prediction':np.ravel(prediction)})
plot.head()

sns.histplot(data=prediction)